const express = require('express');
const path = require('path');
const PresentationController = require('./controllers/presentationController');
const Logger = require('./utils/logger');

class Application {
    constructor() {
        this.app = express();
        this.port = process.env.PORT || 3000;
        this.isProcessing = false;
        this.setupMiddleware();
        this.setupRoutes();
    }

    setupMiddleware() {
        // Servir arquivos est√°ticos (CSS, JS, imagens)
        this.app.use(express.static(path.join(__dirname, 'public')));
        
        // Parser para JSON
        this.app.use(express.json());
        
        // Logs das requisi√ß√µes
        this.app.use((req, res, next) => {
            Logger.info(`${req.method} ${req.url}`);
            next();
        });
    }

    setupRoutes() {
        // Rota principal - serve o index.html
        this.app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, 'public', 'index.html'));
        });

        // Rota para buscar dados (usada pelo frontend)
        this.app.get('/fetch-data', async (req, res) => {
            try {
                Logger.info('Buscando dados para o frontend...');
                const data = await require('./services/dataService').fetchData();
                res.json(data);
            } catch (error) {
                Logger.error('Erro ao buscar dados para frontend', error);
                res.status(500).json({ 
                    error: 'Erro ao buscar dados',
                    message: error.message 
                });
            }
        });

        // Rota para gerar apresenta√ß√µes manualmente
        this.app.post('/generate-presentations', async (req, res) => {
            if (this.isProcessing) {
                return res.status(429).json({ 
                    error: 'Processamento j√° em andamento',
                    message: 'Aguarde o processo atual terminar'
                });
            }

            try {
                this.isProcessing = true;
                Logger.info('Iniciando gera√ß√£o de apresenta√ß√µes via API...');
                
                const options = req.body || {};
                const result = await PresentationController.generateAllPresentations(options);
                
                res.json({
                    success: true,
                    message: 'Apresenta√ß√µes geradas com sucesso',
                    result
                });
                
            } catch (error) {
                Logger.error('Erro na gera√ß√£o via API', error);
                res.status(500).json({ 
                    error: 'Erro ao gerar apresenta√ß√µes',
                    message: error.message 
                });
            } finally {
                this.isProcessing = false;
            }
        });

        // Rota para obter status do sistema
        this.app.get('/status', async (req, res) => {
            try {
                const stats = await PresentationController.getStats();
                res.json({
                    server: 'online',
                    processing: this.isProcessing,
                    stats
                });
            } catch (error) {
                res.status(500).json({ 
                    server: 'online',
                    processing: this.isProcessing,
                    error: error.message 
                });
            }
        });

        // Rota para validar dados
        this.app.get('/validate', async (req, res) => {
            try {
                const validation = await PresentationController.validateData();
                res.json(validation);
            } catch (error) {
                res.status(500).json({ 
                    valid: false, 
                    error: error.message 
                });
            }
        });

        // Middleware para rotas n√£o encontradas
        this.app.use((req, res) => {
            res.status(404).json({ 
                error: 'Rota n√£o encontrada',
                message: `A rota ${req.method} ${req.url} n√£o existe`
            });
        });

        // Middleware para tratamento de erros
        this.app.use((error, req, res, next) => {
            Logger.error('Erro n√£o tratado', error);
            res.status(500).json({ 
                error: 'Erro interno do servidor',
                message: error.message 
            });
        });
    }

    // Executa o processamento autom√°tico em background
    async runAutomaticProcessing() {
        if (this.isProcessing) {
            Logger.warning('Processamento autom√°tico pulado - j√° em execu√ß√£o');
            return;
        }

        try {
            this.isProcessing = true;
            Logger.start('üöÄ AUTOMA√á√ÉO POWERPOINT - SISTEMA INICIADO');
            Logger.info('==================================================');

            // Valida√ß√µes iniciais
            const stats = await PresentationController.getStats();
            
            if (stats.templateExists) {
                Logger.success('‚úÖ Template encontrado e validado');
            }
            
            if (stats.templatePlaceholders) {
                Logger.success(`‚úÖ Placeholders encontrados no template [ ${stats.templatePlaceholders.map(p => `'${p}'`).join(', ')} ]`);
            }

            Logger.success('‚úÖ üìä Status do Sistema:');
            Logger.info(`   Template: ${stats.templateExists ? '‚úÖ' : '‚ùå'}`);
            Logger.info(`   Dados: ${stats.dataSourceExists ? '‚úÖ' : '‚ùå'}`);
            Logger.info(`   Output Dir: ${stats.outputDirExists ? '‚úÖ' : '‚ùå'}`);
            Logger.info(`   Layouts: ${stats.availableLayouts?.join(', ') || 'N/A'}`);
            Logger.info(`   Placeholders: ${stats.templatePlaceholders?.join(', ') || 'N/A'}`);
            Logger.info('==================================================');

            // Executar processamento principal
            const result = await PresentationController.generateAllPresentations();

            if (result.success) {
                Logger.success('==================================================');
                Logger.success(`‚úÖ üéâ PROCESSO CONCLU√çDO COM SUCESSO! ${result.successCount}/${result.totalProcessed} apresenta√ß√µes geradas`);
                Logger.success('==================================================');
            } else {
                throw new Error(result.error);
            }

            return result;

        } catch (error) {
            Logger.error('==================================================');
            Logger.error(`‚ùå üí• FALHA NO PROCESSO ${error.message}`);
            Logger.error('==================================================');
            throw error;
        } finally {
            this.isProcessing = false;
        }
    }

    // Inicia o servidor
    async start() {
        try {
            // Criar diret√≥rio public se n√£o existir
            this.ensurePublicDirectory();

            // Iniciar servidor web
            this.server = this.app.listen(this.port, () => {
                Logger.success('==================================================');
                Logger.success('üåê SERVIDOR WEB INICIADO');
                Logger.success('==================================================');
                Logger.info(`üìç Interface web dispon√≠vel em: http://localhost:${this.port}`);
                Logger.info(`üìä API endpoints:`);
                Logger.info(`   GET  /              - Interface web`);
                Logger.info(`   GET  /fetch-data    - Buscar dados`);
                Logger.info(`   POST /generate-presentations - Gerar apresenta√ß√µes`);
                Logger.info(`   GET  /status        - Status do sistema`);
                Logger.info(`   GET  /validate      - Validar dados`);
                Logger.success('==================================================');
            });

            // Executar processamento autom√°tico ap√≥s iniciar o servidor
            setTimeout(async () => {
                try {
                    await this.runAutomaticProcessing();
                } catch (error) {
                    Logger.error('Erro no processamento autom√°tico inicial', error);
                }
            }, 2000); // Aguarda 2 segundos para o servidor estar totalmente pronto

            // Configurar processamento peri√≥dico (opcional)
            this.setupPeriodicProcessing();

        } catch (error) {
            Logger.error('Erro ao iniciar servidor', error);
            process.exit(1);
        }
    }

    // Configura processamento peri√≥dico (executar a cada X tempo)
    setupPeriodicProcessing() {
        const intervalMinutes = process.env.PROCESS_INTERVAL_MINUTES || 60; // Default: 1 hora
        
        setInterval(async () => {
            Logger.info('üîÑ Executando processamento peri√≥dico...');
            try {
                await this.runAutomaticProcessing();
            } catch (error) {
                Logger.error('Erro no processamento peri√≥dico', error);
            }
        }, intervalMinutes * 60 * 1000);

        Logger.info(`‚è∞ Processamento peri√≥dico configurado para ${intervalMinutes} minutos`);
    }

    // Garante que o diret√≥rio public existe
    ensurePublicDirectory() {
        const fs = require('fs');
        const publicDir = path.join(__dirname, 'public');
        
        if (!fs.existsSync(publicDir)) {
            fs.mkdirSync(publicDir, { recursive: true });
            Logger.info('üìÅ Diret√≥rio public criado');
        }

        // Copia o index.html se ele estiver na raiz
        const indexHtmlSource = path.join(__dirname, 'index.html');
        const indexHtmlTarget = path.join(publicDir, 'index.html');
        
        if (fs.existsSync(indexHtmlSource) && !fs.existsSync(indexHtmlTarget)) {
            fs.copyFileSync(indexHtmlSource, indexHtmlTarget);
            Logger.info('üìÑ index.html copiado para public/');
        }
    }

    // Para o servidor graciosamente
    async stop() {
        if (this.server) {
            Logger.info('üîÑ Parando servidor...');
            this.server.close(() => {
                Logger.success('‚úÖ Servidor parado com sucesso');
            });
        }
    }
}

// Fun√ß√£o principal
async function main() {
    const app = new Application();
    
    // Tratamento de sinais para parada graciosa
    process.on('SIGINT', async () => {
        Logger.info('üì° Recebido SIGINT, parando aplica√ß√£o...');
        await app.stop();
        process.exit(0);
    });

    process.on('SIGTERM', async () => {
        Logger.info('üì° Recebido SIGTERM, parando aplica√ß√£o...');
        await app.stop();
        process.exit(0);
    });

    // Tratamento de erros n√£o capturados
    process.on('uncaughtException', (error) => {
        Logger.error('üí• Erro n√£o capturado', error);
        process.exit(1);
    });

    process.on('unhandledRejection', (reason, promise) => {
        Logger.error('üí• Promise rejeitada n√£o tratada', reason);
        process.exit(1);
    });

    // Iniciar aplica√ß√£o
    await app.start();
}

// Executar se for o arquivo principal
if (require.main === module) {
    main().catch(error => {
        Logger.error('üí• Erro fatal na inicializa√ß√£o', error);
        process.exit(1);
    });
}

module.exports = Application;